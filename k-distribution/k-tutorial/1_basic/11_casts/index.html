<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />
<link rel="canonical" href="https://kframework.org/k-distribution/k-tutorial/1_basic/11_casts/" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../assets/img/favicon.ico" />

<title>K | Runtime Verification Inc</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../k-distribution/pl-tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../pending-documentation/"
        >User documentation</a
      >
      <a
        class="bd-toc-link"
        href="../../../../k-distribution/include/kframework/builtin/"
        >Builtins</a
      >
      <a class="bd-toc-link" href="../../../../projects">Projects using K</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview"><html><head></head><body><h1 id="lesson-1.11%3A-casting-terms">Lesson 1.11: Casting Terms</h1>
<p>The purpose of this lesson is to explain how to use <strong>cast</strong> expressions in
order to disambiguate terms using sort information. We also explain how the
variable sort inference algorithm works in K, and how to change the default
behavior by casting variables to a particular sort.</p>
<h2 id="casting-in-k">Casting in K</h2>
<p>Sometimes the grammar you write for your rules in K can be a little bit
ambiguous on purpose. While grammars for programming languages may be
unambiguous when considered in their entirety, K allows you to write rules
involving arbitrary <strong>fragments</strong> of that grammar, and those fragments can
sometimes be ambiguous by themselves, or similar enough to other fragments
of the grammar to trigger ambiguity. As a result, in addition to the tools
covered in <a href="../04_disambiguation/">Lesson 1.4</a>, K provides one
additional powerful tool for disambiguation: cast expressions.</p>
<p>K provides three main types of casts: the semantic cast, the strict cast, and
the projection cast. We will cover each of them, and their similarities and
differences, in turn.</p>
<h3 id="semantic-casts">Semantic casts</h3>
<p>The most basic, and most common, type of cast in K is called the
<strong>semantic cast</strong>. For every sort <code>S</code> declared in a module, K provies the
following (implicit) production for use in sentences:</p>
<pre class="language-text"><code>  syntax S ::= S &quot;:S&quot;
</code></pre>
<p>Note that <code>S</code> simply represents the name of the sort. For example, if we
defined a sort <code>Exp</code>, the actual production for that sort would be:</p>
<pre class="language-text"><code>  syntax Exp ::= Exp &quot;:Exp&quot;
</code></pre>
<p>At runtime, this expression will not actually exist; it is merely an annotation
to the compiler describing the sort of the term inside the cast. It is telling
the compiler that the term inside the cast must be of sort <code>Exp</code>. For example,
if I had the following grammar:</p>
<pre class="language-k"><code><span class="token keyword">module</span> LESSON<span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span>A
  <span class="token keyword">imports</span> INT

  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token operator">|</span> Exp <span class="token string">&quot;+&quot;</span> Exp
  <span class="token keyword">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Stmt <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
<span class="token keyword">endmodule</span>
</code></pre>
<p>Then we would be able to write <code>1:Exp</code>, or <code>(1 + 2):Exp</code>, but not <code>{}:Exp</code>.</p>
<p>You can also restrict the sort that a variable in a rule will match by casting
it. For example, consider the following additional module:</p>
<pre class="language-k"><code><span class="token keyword">module</span> LESSON<span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span>B
  <span class="token keyword">imports</span> LESSON<span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span>A
  <span class="token keyword">imports</span> BOOL

  <span class="token keyword">syntax</span> Term <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token operator">|</span> Stmt
  <span class="token keyword">syntax</span> <span class="token keyword">Bool</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> isExpression<span class="token punctuation">(</span>Term<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>

  <span class="token keyword">rule</span> isExpression<span class="token punctuation">(</span>E<span class="token punctuation">:</span>Exp<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword">rule</span> isExpression<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">false</span> <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>
<span class="token keyword">endmodule</span>
</code></pre>
<p>Here we have defined a very simple function that decides whether a term is
an expression or a statement. It does this by casting the variable inside the
<code>isExpression</code> rule to sort <code>Exp</code>. As a result, that variable will only match terms
of sort <code>Exp</code>. Thus, <code>isExpression(1)</code> will return true, as will <code>isExpression(1 + 2)</code>, but
<code>isExpression({})</code> will return false.</p>
<h4 id="exercise">Exercise</h4>
<p>Verify this fact for yourself by running <code>isExpression</code> on the above examples. Then
write an <code>isStmt</code> function, and test that it works as expected.</p>
<h3 id="strict-casts">Strict casts</h3>
<p>On occasion, a semantic cast is not strict enough. It might be that you want
to, for disambiguation purposes, say <strong>exactly</strong> what sort a term is. For
example, consider the following definition:</p>
<pre class="language-k"><code><span class="token keyword">module</span> LESSON<span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span>C
  <span class="token keyword">imports</span> INT

  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token operator">|</span> Exp <span class="token string">&quot;+&quot;</span> Exp <span class="token punctuation">[</span>exp<span class="token punctuation">]</span>
  <span class="token keyword">syntax</span> Exp2 <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token operator">|</span> Exp2 <span class="token string">&quot;+&quot;</span> Exp2 <span class="token punctuation">[</span>exp2<span class="token punctuation">]</span>
<span class="token keyword">endmodule</span>
</code></pre>
<p>This grammar is a little ambiguous and contrived, but it serves to demonstrate
how a semantic cast might be insufficient to disambiguate a term. If I were
to write the term <code>(I1:Int + I2:Int):Exp2</code>, the term would be ambiguous,
because the cast is not sufficiently strict to determine whether you mean
to derive the &quot;+&quot; production tagged <code>exp</code>, or the one tagged <code>exp2</code>.</p>
<p>In this situation, there is a solution: the <strong>strict cast</strong>. For every sort
<code>S</code> in your grammar, K also defines the following production:</p>
<pre class="language-text"><code>  syntax S ::= S &quot;::S&quot;
</code></pre>
<p>This may at first glance seem the same as the previous cast. And indeed,
from the perspective of the grammar and from the perspective of rewriting,
they are in fact identical. However, the second variant has a unique meaning
in the <strong>type system</strong> of K: namely, the term inside the cast cannot be a
<strong>subsort</strong>, i.e., a term of another sort <code>S2</code> such that the production
<code>syntax S ::= S2</code> exists.</p>
<p>As a result, if we were to write in the above grammar the term
<code>(I1:Int + I2:Int)::Exp2</code>, then we would know that the first derivation above
should be chosen, whereas if we want the second derivation, we could write
<code>(I1:Int + I2:Int)::Exp</code>.</p>
<h4 id="exercise-1">Exercise</h4>
<p>Write a function <code>eval</code> which takes a term of sort <code>Exp2</code> and returns an <code>Int</code>.
The function should be capable of evaluating any term of sort <code>Exp2</code> to the
integer value which it expresses. You will need to write strict casts in order
to disambiguate these rules.</p>
<h3 id="projection-casts">Projection casts</h3>
<p>Sometimes, when dealing with grammars containing subsorts, it can be desirable
to reason with the subsort production itself, which <strong>injects</strong> one sort into
another. Remember from above that such a production looks like
<code>syntax S ::= S2</code>. This type of production, called a <strong>subsort production</strong>,
can be thought of as a type of inheritance involving constructors. If we have
the above production in our grammar, we say that <code>S2</code> is a subsort of <code>S</code>,
or that any <code>S2</code> is also an <code>S</code>. K implicitly maintains a symbol at runtime
which keeps track of where such subsortings occur; this symbol is called
an <strong>injection</strong>.</p>
<p>Sometimes, when one sort is a subsort of another, it can be the case that
a function returns one sort, but you actually want to cast the result of
calling that function to another sort which is a subsort of the first sort.
This is similar to what happens with inheritance in an object-oriented
language, where you might cast a superclass to a subclass if you know for
sure the object at runtime is in fact an instance of that class.</p>
<p>K provides something similar for subsorts: the <strong>projection cast</strong>.</p>
<p>For each pair of sorts <code>S</code> and <code>S2</code>, K provides the following production:</p>
<pre class="language-text"><code>  syntax S ::= &quot;{&quot; S2 &quot;}&quot; &quot;:&gt;S&quot;
</code></pre>
<p>What this means is that you take any term of sort <code>S2</code> and <strong>cast</strong> it to sort
<code>S</code>. If the term of sort S2 consists of an injection containing a term of sort
<code>S</code>, then this will return that term. Otherwise, an error occurs and rewriting
fails, returning the projection function which failed to apply.</p>
<p>For example, here is an example that makes use of projection casts:</p>
<pre class="language-k"><code><span class="token keyword">module</span> LESSON<span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span>D
  <span class="token keyword">imports</span> INT

  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token operator">|</span> <span class="token keyword">Bool</span> <span class="token operator">|</span> Exp <span class="token string">&quot;+&quot;</span> Exp <span class="token operator">|</span> Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp

  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> eval<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span> <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> eval<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> I
  <span class="token keyword">rule</span> eval<span class="token punctuation">(</span>B<span class="token punctuation">:</span><span class="token keyword">Bool</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> B
  <span class="token keyword">rule</span> eval<span class="token punctuation">(</span>E1 <span class="token operator">+</span> E2<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>eval<span class="token punctuation">(</span>E1<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;<span class="token keyword">Int</span> <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token punctuation">{</span>eval<span class="token punctuation">(</span>E2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;<span class="token keyword">Int</span>
  <span class="token keyword">rule</span> eval<span class="token punctuation">(</span>E1 <span class="token operator">&amp;&amp;</span> E2<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>eval<span class="token punctuation">(</span>E1<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;<span class="token keyword">Bool</span> andBool <span class="token punctuation">{</span>eval<span class="token punctuation">(</span>E2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">:</span>&gt;<span class="token keyword">Bool</span>
<span class="token keyword">endmodule</span>
</code></pre>
<p>Here we have defined constructors for a simple expression language over
Booleans and integers, as well as a function <code>eval</code> that evaluates these
expressions to a value. Because that value could be an integer or a Boolean,
we need the casts in the last two rules in order to meet the type signature of
<code>+Int</code> and <code>andBool</code>. Of course, the user can write ill-formed expressions like
<code>1 &amp;&amp; true</code> or <code>false + true</code>, but these will cause errors at runtime, because
the projection cast will fail.</p>
<h2 id="exercises">Exercises</h2>
<ol>
<li>
<p>Extend the <code>eval</code> function in <code>LESSON-11-D</code> to include Strings and add a <code>.</code>
operator which concatenates them.</p>
</li>
<li>
<p>Modify your solution from lesson 1.9, problem 2 by using an <code>Exp</code> sort to
express the integer and Boolean expressions that it supports, in the same style
as <code>LESSON-11-D</code>. Then write an <code>eval</code> function that evaluates all terms of
sort <code>Exp</code> to either a <code>Bool</code> or an <code>Int</code>.</p>
</li>
</ol>
<h2 id="next-lesson">Next lesson</h2>
<p>Once you have completed the above exercises, you can continue to
<a href="../12_syntactic_lists/">Lesson 1.12: Syntactic Lists</a>.</p>
</body></html></div>
        </main>
      </div>
    </div>
<!-- The footer is now controlled by the k-web-theme git submodule -->
<footer id="rvsite-footer" class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-4 mb-md-0 mb-4">
        <a href="https://runtimeverification.com/" target="_blank">
          <picture>
            <source
              srcset="
                https://runtimeverification.com/assets/img/rv-logo-dark.png
              "
              media="(prefers-color-scheme: dark)"
            />
            <img
              class="logo-dark"
              src="https://runtimeverification.com/assets/img/rv-logo.png"
              alt="Runtime Verification logo"
              style="height: 32px"
            /> </picture
        ></a>
        <p class="mt-2 text-md-left copyright">
          <a href="https://goo.gl/maps/NYzr2iKpXMgEmQ2F6" target="_blank"
            >102 E Main St #500, Urbana, IL 61801</a
          >
        </p>
      </div>
      <div class="col-md-4 text-md-center mb-md-0 mb-4"></div>
      <div class="col-md-4 mb-md-0 mb-4 text-md-right">
        <p class="copyright">2021 Â© all rights reserved</p>
      </div>
    </div>
  </div>
</footer>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-9LBGDMRG32"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());
      gtag("config", "G-9LBGDMRG32");
    </script>
  </body>
</html>
